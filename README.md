# AHC049

#　問題　

# 考え方

解法1　
近いところから取ってくる方法
１つずつ

得点180,000
順位　31位

解法２
まとめて運ぶことから考える

プロジェクト概要：ダンボール箱運搬シミュレーション
このプロジェクトは、AtCoder社が新しいオフィスへ引っ越す際に直面する、ダンボール箱の運搬問題を解決するためのシミュレーションプログラムです。高橋社長が一人で、大量のダンボール箱を旧オフィスから出入り口（座標 (0,0)）まで運び出す方法をシミュレートし、できるだけ少ない移動回数で、かつ箱を一つも潰さずに全ての箱を運び出すことを目標とします。

問題設定
N × N マスのオフィス（N=20 に固定）。(0,0) が出入り口。
(0,0) 以外の各マスには、重さ w と耐久力 d を持つダンボール箱が1つずつ置かれている。
高橋社長は以下の操作を繰り返して箱を運び出します。
持ち上げる (1): 現在位置の箱を手に取る。手に箱がある場合は一番上に重ねる。
置く (2): 手に持っている一番上の箱を現在位置に置く（現在位置に箱がない場合のみ）。
移動 (U/D/L/R): 上下左右に隣接するマスへ移動する。
耐久力とダメージ:
移動（操作3）するたびに、手に持っている箱の耐久力が減少する。
箱の耐久力減少量は、その箱の上に積まれているダンボール箱の総重量に等しい。このダメージは移動距離1マスごとに適用される。
耐久力が 0 以下になった箱は潰れてしまい、失敗となる。
(0,0) に移動すると、手に持っている箱はすべて運び出される。
目標: すべての箱を潰さずに運び出し、移動回数を最小化する。

解決戦略
本プログラムでは、貪欲法に基づいたサイクル型の戦略を採用しています。

輸送サイクルの繰り返し:

すべての箱が運び出されるまで、以下のプロセスを繰り返します。
各サイクルは (0,0) から開始し、手ぶらの状態です。
一度手に取った箱は、そのサイクル中にすべて (0,0) へ運び出すことを前提としています（「置く」操作は使用しません）。
最適な箱の選択と計画の構築:

現在位置（または計画の最後の箱の場所）から、まだ運び出されていない箱の中から、「最も近く」、かつ**「現在の計画に加えても箱が潰れない」**ものを優先的に選んでいきます。
この「潰れない」という条件を厳密にチェックするため、isPlanFeasible() メソッドで綿密なシミュレーションを行います。
isPlanFeasible() による耐久性シミュレーション:

このメソッドは、提案された箱の運搬計画（どの箱をどの順で拾い、どこからどこへ移動するか）が、実際にすべての箱の耐久力を 0 より大きく保てるかを事前にシミュレートします。
シミュレーションでは、実際の箱の状態を変更しないよう、箱のディープコピーを使用します。
各移動（箱を拾いに行く移動、そして (0,0) への帰還移動）ごとに、手に持っている箱のスタックを下から順に確認し、その箱の上に積まれている箱の総重量を基にダメージを計算します。
計算の結果、一つでも箱の耐久力が 0 以下になった場合、その計画は「不可能」と判断され、即座に false を返します。
箱の積み上げ方:

高橋社長が箱を「手に持つ」操作を行うと、その箱は**現在手に持っている箱のスタックの「一番上」**に自動的に追加されます。
ダメージ計算時には、このスタックを「一番上」から「一番下」へと逆順にたどり、各箱の「上にある箱の総重量」を正確に算出することで、ダメージを適用します。これにより、問題のルールに厳密に従った耐久力管理が行われます。
計画の実行:

isPlanFeasible() で問題ないと判断された計画が確定したら、実際にその計画に沿って移動 (moveTo()) し、箱を拾い上げ (pick())、最終的に (0,0) へ戻ります。この際、moveTo() メソッドでも実際に手に持っている箱の耐久力が更新されます。
コード構造
Main.java: 入力を読み込み、Solver クラスのインスタンスを生成して実行を開始する。
Box.java: 各ダンボール箱の属性（ID、座標、重さ、初期耐久力、現在耐久力）を保持するデータクラス。耐久力はオーバーフローを防ぐために long 型で管理される。
Solver.java:
N: グリッドサイズ。
px, py: 高橋社長の現在座標。
hand: 手に持っている箱のリスト。
actions: 実行された操作コマンドを記録する StringBuilder。
boxes: 全ての箱をIDで管理するマップ。
solve(): 全体のアルゴリズムを実行するメインメソッド。
isPlanFeasible(): 計画の実行可能性をシミュレートする重要メソッド。
moveTo(): 指定座標へ移動し、手に持っている箱にダメージを適用する。
pick(): 現在位置の箱を手に取る。

得点1,525,094


解法３

💡 プログラムの主な工夫点
このソルバーは、以下の主要な工夫によって輸送効率と安全性を高めています。

賢い計画立案 (Smart Greedy Planning)
一度に複数の箱を運ぶ計画を立てる際、単に社長から一番近い箱を選ぶだけではありません。「移動距離」 と 「箱の重さ」 の両方を考慮した独自の評価関数 (移動距離 / 箱の重さ) を用いて、次に拾うべき最も効率的な箱を決定します。これにより、同じ距離であればより重い箱を、同じ重さであればより近い箱を優先的に選び、全体としての輸送効率を向上させます。

事前シミュレーションによる安全確認 (Feasibility Simulation)
実際に箱を運ぶアクションを実行する前に、立案された輸送計画（どの箱をどの順番で拾うか）が、手持ちの箱を壊さずに完了できるかを詳細にシミュレーションします。シミュレーションでは、移動によって箱に蓄積されるダメージを正確に計算し、耐久力が尽きてしまう箱がないかを確認します。この厳密な事前チェックにより、箱が壊れるリスクを未然に回避し、安全が保証された計画のみを実行します。

柔軟なフォールバック戦略 (Flexible Fallback Strategy)
もし複数の箱をまとめて運ぶ計画が安全でない、またはこれ以上計画に箱を追加できないと判断された場合でも、プログラムは諦めません。まだ輸送されていない箱の中に、単独であれば安全に運べる箱がないかを再試行し、可能な限り多くの箱を輸送しようとします。これにより、どんな状況でも最大限の努力でタスク完了を目指します。

🚀 動作フローの概要
本ソルバーは、未輸送の箱がなくなるまで、以下のサイクルを繰り返して動作します。

輸送サイクルの開始: 社長がスタート地点の (0,0) へ移動し、手持ちの箱をすべて下ろして、新たな輸送準備を整えます。
最適な輸送計画の立案:
社長の現在地から、最も効率的な（「移動距離 / 箱の重さ」の値が最小となる）未輸送の箱を候補として選びます。
この候補箱を計画に加えた場合、全ての箱が破損せずに (0,0) へ帰還できるかを事前にシミュレーションします。
安全が確認された場合のみ、その箱を計画に追加します。このプロセスを繰り返すことで、一度に運べる箱の数を最大化します。
もし複数の箱を運ぶ計画が立てられない場合でも、単独で運べる箱がないか再探索します。
計画の実行:
立案された計画に従い、社長は各箱の場所へ移動し（移動コマンド U, D, L, R）、箱を拾い上げます（操作 1）。
移動中、手持ちの箱には上層の箱の重さに応じたダメージが蓄積されます。
全ての計画された箱を拾い終えたら、社長は (0,0) へ帰還します。
輸送状況の更新と次のサイクル: 輸送が完了した箱は「未輸送リスト」から除外されます。まだ運ぶべき箱が残っていれば、ステップ1に戻り、次の輸送サイクルを開始します。
タスク完了: 全ての箱が輸送されたら、それまでの全ての操作コマンドが出力され、プログラムは終了します。

得点:1,720,818 